#include "BaseService.h"

#include <iostream>
#include <time.h>
#include "ServiceMgr.h"
using namespace google::protobuf;
CBaseService::CBaseService()
{

}

CBaseService* CBaseService::New()
{

}

CBaseService::CBaseService(CServiceMgr* owner,int SID=0, std::string serviceName="") 
	//m_owner((CServiceMgr*)owner), m_SID(SID), m_serviceName(serviceName)
{
	this->m_owner = owner;
	this->m_serviceID = SID;
	this->m_serviceName = serviceName;
}

google::protobuf::Message* CBaseService::GetMethodMessage(int MethodID, bool request) {
	switch (MethodID) {
		case 1:
			if (request) { return ::bnet::protocol::connection::ConnectRequest::default_instance().New(); }
			else { return ::bnet::protocol::connection::ConnectResponse::default_instance().New(); }
		case 2:
			if (request) { return ::bnet::protocol::connection::BindRequest::default_instance().New(); }
			else { return bnet::protocol::connection::BindResponse::default_instance().New(); }

		default:
			cerr << "error: method not implemented" << endl;
			return NULL;
	}
}

//This function was autogenerated:
bool CBaseService::DispatchMethod(int MethodID, bool request, TCPSocket *sock, apacket* packet) {
	switch (MethodID) {
		case 1:
			if (request) { return handle_ConnectRequest(sock, packet); }
			else {	return handle_ConnectResponse(sock, packet); }
		case 2:
			if (request) { return handle_BindRequest(sock, packet); }
			else {	return handle_BindResponse(sock, packet); }

		default:
			cerr << "error: method not implemented" << endl;
			return false;
	}
}
bool CBaseService::handle_ConnectRequest(TCPSocket *sock, apacket* packet)
{
	bnet::protocol::connection::ConnectResponse resp;
	resp.mutable_server_id()->set_label(0xAAAA);
	resp.mutable_server_id()->set_epoch(time(NULL));
	resp.mutable_client_id()->set_label(0xBBBB);
	resp.mutable_client_id()->set_epoch(time(NULL));

	sendheader(sock, 0xFE, 0, packet->hdr->reqid, 0, resp.ByteSize());
	sendmsgdata(sock, &resp);
	return true;
}

int foxhole = 22;
bool CBaseService::handle_BindRequest(TCPSocket *sock, apacket* packet)
{
	bnet::protocol::connection::BindRequest* request = (bnet::protocol::connection::BindRequest*)packet->msg;
	bnet::protocol::connection::BindResponse bindres;

	cout << "bind request handler called!" << endl ;
	cout << request->imported_service_hash_size() << endl;
	request->DebugString();
	CService* svc = 0;
	for (int i = 0; i < request->imported_service_hash_size(); i++) {
			int hash = request->imported_service_hash(i);
			 svc = m_owner->find_service_by_server_hash(hash);
			if(svc == 0) {
			cout << "unknow service hash: " << request->imported_service_hash(i) << endl;
			foxhole++;
			bindres.add_imported_service_id(foxhole);
		}
		else {
			bindres.add_imported_service_id(svc->GetSID());
		}
	}
	cout << "reply size? " << bindres.ByteSize() << endl ;
	printmsgdata(&bindres);

	sendheader(sock, 0xFE, 0, packet->hdr->reqid, 0, bindres.ByteSize());
	sendmsgdata(sock, &bindres);
	return true;
}

bool CBaseService::handle_ConnectResponse(TCPSocket *sock, apacket* packet) {
	cout << "FIXME: warning, Connection::ConnectResponse called and not implemented" << endl;
	return false;
}

bool CBaseService::handle_BindResponse(TCPSocket *sock, apacket* packet) {
	cout << "FIXME: warning, Connection::BindResponse called and not implemented" << endl;
	return false;
}

CBaseService::~CBaseService(void)
{
	std::cout << "Bye from "<< m_serviceName << std::endl;
}
